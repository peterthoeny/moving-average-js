<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script src="./moving-average.js"></script>
<style>
    body, p { font-family: "Helvetica Neue",Helvetica,Arial,sans-serif; }
</style>
</head>
<body onload="drawGraph();">
<h3>Moving Average Demo (WIP)</h3>
<canvas id="graphCanvas" style="margin: 10px;" width="1090" height="590"></canvas>
<script>
function arrayToSpline(arr, tension, numOfSegments) {
    var pts = [];
    for(var i = 0; i < arr.length; i++) {
        pts.push(i);
        pts.push(arr[i]);
    }
    tension = (typeof tension != 'undefined') ? tension : 0.5;
    numOfSegments = numOfSegments ? numOfSegments : 16;
    var res = [],
        x, y,           // our x,y coords
        t1x, t2x, t1y, t2y, // tension vectors
        c1, c2, c3, c4,     // cardinal points
        st, t, i;       // steps based on num. of segments
    pts.unshift(pts[1]);   // copy first point and insert at beginning
    pts.unshift(pts[0]);
    pts.push(pts[pts.length - 2]); // copy last point and append
    pts.push(pts[pts.length - 1]);
    // 1. loop goes through point array
    // 2. loop goes through each segment between the 2 pts + 1e point before and after
    for (i=2; i < (pts.length - 4); i+=2) {
        for (t=0; t <= numOfSegments; t++) {
            // calc tension vectors
            t1x = (pts[i+2] - pts[i-2]) * tension;
            t2x = (pts[i+4] - pts[i]) * tension;
            t1y = (pts[i+3] - pts[i-1]) * tension;
            t2y = (pts[i+5] - pts[i+1]) * tension;
            // calc step
            st = t / numOfSegments;
            // calc cardinals
            c1 =   2 * Math.pow(st, 3)  - 3 * Math.pow(st, 2) + 1; 
            c2 = -(2 * Math.pow(st, 3)) + 3 * Math.pow(st, 2); 
            c3 =       Math.pow(st, 3)  - 2 * Math.pow(st, 2) + st; 
            c4 =       Math.pow(st, 3)  -     Math.pow(st, 2);
            // calc x and y cords with common control vectors
            x = c1 * pts[i]    + c2 * pts[i+2] + c3 * t1x + c4 * t2x;
            y = c1 * pts[i+1]  + c2 * pts[i+3] + c3 * t1y + c4 * t2y;
            //store points in array
            res.push({ x: x, y: y });
        }
    }
    return res;
}

function drawGraph() {
    drawGrid();
    var arr = [ 1, 2, 4, 5, 5, 8, 9, 7, 7, 6 ];
    drawLine(arr, '#ee3333');
    var maArr = movingAverage(arr, 'SMA', 7);
    drawLine(maArr, '#33ee33', true);
}

function drawLine(arr, color, isSpline) {
    function xTr(x) {
        return x * 50 + 30 + 6 * 50;
    }
    function yTr(y) {
        return 10 + 10 * 50 - y * 50;
    }
    var canvas = document.getElementById('graphCanvas');
    if(canvas.getContext) {
        var ctx = canvas.getContext('2d');
        ctx.lineWidth = 1;
        ctx.strokeStyle  = color;
        ctx.beginPath();
        var xOffset = 30 + 6 * 50;
        var yOffset = 10 + 10 * 50;
        ctx.moveTo(xTr(0), yTr(arr[0]));
        if(isSpline) {
            var pts = arrayToSpline(arr);
            ctx.moveTo(xTr(pts[0].x), yTr(pts[0].y));
            for(var i = 1; i < pts.length; i++) {
                ctx.lineTo(xTr(pts[i].x), yTr(pts[i].y));
            }
        } else if(0 && isSpline) {
            for(var i = 0; i < arr.length-1; i ++) {
                var x_mid = (i + i + 1) / 2;
                var y_mid = (arr[i] + arr[i+1]) / 2;
                var cp_x1 = (x_mid + i) / 2;
                var cp_x2 = (x_mid + i + 1) / 2;
                ctx.quadraticCurveTo(xTr(cp_x1), yTr(arr[i]),   xTr(x_mid), yTr(y_mid));
                ctx.quadraticCurveTo(xTr(cp_x2), yTr(arr[i+1]), xTr(i+1),   yTr(arr[i+1]));
            }
        } else if(0 && isSpline) {
            for(var i = 1; i < arr.length - 2; i++) {
                var xc = (i + i + 1) / 2;
                var yc = (arr[i] + arr[i + 1]) / 2;
                ctx.quadraticCurveTo(xTr(i), yTr(arr[i]), xTr(xc), yTr(yc));
            }
            ctx.quadraticCurveTo(xTr(i), yTr(arr[i]), xTr(i+1), yTr(arr[i+1]));
        } else {
            for(var i = 1; i < arr.length; i++) {
                ctx.lineTo(xTr(i), yTr(arr[i]));
            }
        }
        ctx.stroke();
    }
}

function drawGrid() {
    var canvas = document.getElementById('graphCanvas');
    if (canvas.getContext) {
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f6f6fb';
        ctx.fillRect(30 + 6 * 50, 10 + 50, 450, 450);
        ctx.lineWidth = 1;
        ctx.strokeStyle  = '#666666';
        ctx.strokeRect(30, 10, 1050, 550);
        ctx.strokeStyle  = '#111111';
        ctx.strokeRect(30 + 6 * 50, 10 + 50, 450, 450);
        ctx.strokeStyle  = '#999999';
        ctx.font = '14px Sans-Serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#333333';
        for(var i = 0; i < 21; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 50 + 30, 10);
            ctx.lineTo(i * 50 + 30, 560);
            ctx.stroke();
            ctx.fillText(i - 6, i * 50 + 37, 524);
        }
        for(var i = 0; i < 12; i++) {
            ctx.beginPath();
            ctx.moveTo(30, i * 50 + 10);
            ctx.lineTo(1080, i * 50 + 10);
            ctx.stroke();
            ctx.fillText(10 - i, 17, i * 50 + 16);
        }
        //ctx.fillText(10, 10 * 50 + 26, 530);
    }
}
</script>

</body>
</html>







</div></body></html>